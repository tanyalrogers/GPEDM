% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Smapfunctions.R
\name{fitSmap}
\alias{fitSmap}
\title{Fit an S-map model}
\usage{
fitSmap(
  data = NULL,
  y,
  x = NULL,
  pop = NULL,
  time = NULL,
  E = NULL,
  tau = NULL,
  thetafixed = NULL,
  exclradius = 0,
  ns = FALSE,
  nsvar = time,
  deltafixed = NULL,
  scaling = c("global", "local", "none"),
  initpars = NULL,
  augdata = NULL,
  returninsamp = FALSE,
  predictmethod = NULL,
  newdata = NULL,
  xnew = NULL,
  popnew = NULL,
  timenew = NULL,
  ynew = NULL
)
}
\arguments{
\item{data}{A data frame, or matrix with named columns.}

\item{y}{The response variable (required). If \code{data} is supplied, a column name
(character) of index (numeric). If \code{data} is not supplied, a numeric vector.}

\item{x}{Predictor variables. If \code{data} is supplied, column names
(character vector) of indices (numeric vector). If \code{data} is not supplied, a numeric matrix
(or vector, if there is only one predictor variable). If \code{x} is not supplied,
values for \code{E} and \code{tau} must be provided to construct it internally.}

\item{pop}{Identifies separate populations (optional, if not supplied, defaults to 1
population). Population values can be either numeric, character, or factor.
If \code{data} is supplied, a column name (character) of index (numeric).
If \code{data} is not supplied, a vector (numeric, character, or factor).}

\item{time}{A time index (optional, if not supplied, defaults to a numeric index).
Important: The time index is not used for model fitting (timesteps are
assumed to be evenly spaced) but supplying \code{time} will be add these values to the output table,
which may be useful for later plotting purposes. If \code{data} is supplied, a column name
(character) of index (numeric). If \code{data} is not supplied, a numeric vector.}

\item{E}{Embedding dimension. If supplied, will be used to constuct lags of \code{x} (or
lags of \code{y} if \code{x} is not supplied).}

\item{tau}{Time delay. If supplied, will be used to constuct lags of \code{x} (or
lags of \code{y} if \code{x} is not supplied).}

\item{thetafixed}{Fixes the theta parameter, if desired (see Details).}

\item{exclradius}{Exclusion radius. How many adjacent time steps on either side of the focal
point should be excluded when fitting the local linear model? Defaults to 0 (none).
This setting is retained when making other types of predictions. Must be a positive integer.}

\item{ns}{Logical. Use nonstationary s-map (or not). Defaults to FALSE.}

\item{nsvar}{If \code{ns=TRUE}, the variable supplied under \code{time} is used by default.
If for some reason you want to use a different variable, supply it here (column name of
\code{data}).}

\item{deltafixed}{If \code{ns=TRUE}, fixes the delta parameter, if desired (see Details).}

\item{scaling}{How the variables should be scaled (see Details). Scaling can be \code{"global"},
\code{"local"} (only applicable if more than 1 pop), or \code{"none"} (default). Scaling is applied
to \code{y} and each \code{x}. All outputs are backtransformed to original scale.}

\item{initpars}{Starting values for hyperparameters (see Details) in the order
\code{c(theta,delta)}. Should be a numeric vector with length 2. Defaults used
if not supplied: \code{c(0,0)}.}

\item{augdata}{A data frame with augmentation data (see Details).}

\item{returninsamp}{Return the in-sample results? Default to FALSE. The in-sample
results from s-map are generally not that useful, but you can get them if you want.}

\item{predictmethod}{Using the training data, \code{lto} does
leave-timepoint-out prediction, and \code{sequential} does sequential (leave-future-out)
prediction.}

\item{newdata}{Data frame containing the same columns supplied in the
original model.}

\item{xnew}{New predictor matrix or vector. Not required if \code{newdata} is supplied.}

\item{popnew}{New population vector. Not required if \code{newdata} is supplied.}

\item{timenew}{New time vector. Not required if \code{newdata} is supplied.}

\item{ynew}{New response vector. Optional, unless \code{E} and \code{tau} were supplied in
lieu of \code{x}. Not required if \code{newdata} is supplied.}
}
\value{
A list (class Smap and Smappred) with the following elements:
\item{theta}{Maximum likelihood value of theta.}
\item{delta}{For nonstationary models, maximum likelihood value of delta. Will be fixed to 0 for standard s-map models.}
\item{sigma2}{Variance estimate for the model (mean squared deviations), from leave-one-out.}
\item{grad}{Likelihood gradients of hyperparameters. Can be used to assess convergence.}
\item{iter}{Number of iterations until convergence was reached. Currently fixed at a max of 200.}
\item{ns}{Whether the model is nonstationary.}
\item{inputs}{Inputs and scaled inputs. Note that if you use \code{E} and \code{tau},
the names of the predictors in the input data frame will be stored under
\code{x_names}, and the names of the lagged predictors corresponding to the
inverse length scales will be stored under \code{x_names2}, provided these names exist.}
\item{scaling}{Scaling information.}
\item{looresults}{Data frame with leave-one-out out-of-sample predictions.}
\item{loocoefs}{Data frame of s-map coefficients from leave-one-out. The last column is the intercept.}
\item{loofitstats}{Fit statistics for leave-one-out out-of-sample predictions.}
\item{loofitstatspop}{If >1 population, fit statistics for leave-one-out out-of-sample predictions by population.}
\item{call}{Function call. Allows use of \code{\link{update}}.}
}
\description{
Fits a S-map (local linear) model with local weighting parameter theta found using
gradient descent. Includes implementation of the nonstationary S-map.
}
\details{
There are several ways to specify the training data:
\itemize{
\item A. supply data frame \code{data}, plus column names or indices for \code{y}, \code{x}, \code{pop}, and \code{time}.
\item B. supply vectors for \code{y}, \code{pop}, and \code{time}, and a matrix or vector for \code{x}.
}
For each of the above 2 options, there are 3 options for specifying the predictors.
\enumerate{
\item supplying \code{y} and \code{x} (omitting \code{E} and \code{tau}) will use the columns of \code{x} as predictors. This allows
for the most customization.
\item supplying \code{y}, \code{E}, and \code{tau} (omitting \code{x}) will use \code{E} lags of \code{y} (with spacing \code{tau}) as predictors.
This is equivalent to option 3 with \code{x}=\code{y}.
\item supplying \code{y}, \code{x}, \code{E}, and \code{tau} will use \code{E} lags of \emph{each column} of \code{x} (with spacing \code{tau}) as predictors.
Do not use this option if \code{x} already contains lags, in that case use option 1.
}
Arguments \code{pop} and \code{time} are optional in all of the above cases.
If \code{pop} and \code{time} are supplied, they should NOT contain missing values.
This function will also, optionally, produce predictions.
See Details for more information.

The data are assumed to be in time order. This is particularly important if \code{E} and \code{tau}
are supplied or \code{predictmethod="sequential"} is used.

The S-map model does not include a hierarchical stucture like the GP model. If multiple
populations are supplied, their dynamics are assumed to be identical. The \code{pop}
argument is only relevant if you are supplying \code{E} and \code{tau} to generate
lags internally (to ensure there isn't crossover among populations), or if you want to
keep track (in the results tables) of which predictions are from which population.
The model fitting code itself does not use the population designations.

\strong{Missing values:}

Missing values for \code{y} and \code{x} are allowed. Any rows containing
missing values will be excluded from the model fitting procedure (reinserted
as NAs in the output). If \code{pop} and \code{time} are supplied, they
should NOT contain missing values.

\strong{Hyperparameters:}

Hyperparameter \code{theta} is the s-map local weighting parameter. A value of 0
corresponds to a globally linear model. The value can be fixed using \code{thetafixed},
otherwise it is estimated using gradient descent.

The nonstationary implementation of s-map (ns-map) includes an additional
hyperparameter \code{delta}, which is the local weighting in time (as opposed
to state space, which is controlled by \code{theta}). In the standard s-map
(default \code{ns=FALSE}), \code{delta} is fixed to 0. If fitting a
nonstationary model (\code{ns=TRUE}), the value of \code{delta} can be fixed
using \code{deltafixed}, otherwise it is estimated using gradient descent,
along with \code{theta}. A dynamic linear model (DLM) can be approximated by
fixing \code{theta} to 0 and estimating \code{delta}.

\strong{Scaling:}

Scaling in s-map is not as essential as in the GP model, since \code{theta}
is scaled interally to the average distance among points. If you are doing
univariate delay embedding, the results will be unaffected by the scaling of
the data. However, if you are fitting a multivariate model, you will need to
think about data scaling, since the weights are applied equally in all
dimensions, and the predictors are no longer in the same units. It is common
to standardize all of the predictors in a multivariate model.

For convenience, this function will scale the input data automatically by
default, and backtransform output to the original scale. Automatic scaling
can be \code{"global"} (default), or \code{"local"}. The latter will scale
variables within (as opposed to across) populations, so is obviously only
applicable if there is more than 1 population. You can also set
\code{scaling="none"}.

Note that if you use automatic scaling, the s-map coefficients and sigma2 value
will be for the scaled data, not the original data.

If you are fitting a nonstationary model, the time variable is NOT automatically
scaled when using \code{scaling}, since it has a separate weighting parameter
\code{delta}. The interpretability of \code{delta} (i.e. whether it expresses
relative or absolute weighting in time), depends on how time has been scaled,
so depending on your goals, you might choose to leave time in its original units,
or scale it from 0 to 1.

\strong{Predictions:}

The s-map routine automatically does leave-one-out prediction, which is included in the
output, so there is no separate \code{predictmethod="loo"}. The in-sample predictions
are not automatically returned, since they are of limited utility, however you can
obtain them by setting \code{returninsamp=TRUE}.

There are several addtional options for producing predictions:
\enumerate{
\item Use \code{predictmethod="lto"} for leave-timepoint-out prediction using the training data. This will leave
out values with the same time index across multiple populations, rather than each individual datapoint.
If there is only one population, \code{"lto"} will be equivalent to \code{"loo"}.
\item Use \code{predictmethod="sequential"} for sequential (leave-future-out) prediction using the training data.
\item If data frame \code{data} was supplied, supply data frame \code{newdata} containing same column names.
Column for \code{y} is optional, unless \code{E} and \code{tau} were supplied in lieu of \code{x}.
\item If vectors/matrices were supplied for \code{y}, \code{x}, etc, equivalent vector/matrices \code{xnew},
\code{popnew} (if \code{pop} was supplied), and \code{timenew} (optional).
\code{ynew} is optional, unless \code{E} and \code{tau} were supplied in lieu of \code{x}.
}

After fitting, predictions can also be made using \code{\link{predict.Smap}}.
Predictions can plotted using \code{\link{plot.Smappred}}.
Get conditional responses using \code{\link{getconditionals}}.
}
\examples{

}
\references{

}
\seealso{
\code{\link{predict.Smap}}, \code{\link{plot.Smappred}}, \code{\link{getconditionals}}
}
\keyword{functions}
