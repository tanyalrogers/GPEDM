---
title: "S-map and Extensions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{smap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(GPEDM)
library(ggplot2)
```

## Introduction

This package includes an implementation of S-map EDM as described in Sugihara (1994), with a kernel modification to allow for nonstationarity analogous to a dynamic linear model (DLM), as described in Gee, Rogers, and Munch (in prep). 

For point $x_{t*}$, the weight given to point $x_{t}$ in the S-map local linear regression is:

$$w_t=\exp(-\theta\frac{||x_t-x_{t*}||}{d}-\delta(t-t^*)^2)$$

where $\theta$ is the weighting in based on Euclidean distance in state space ($\theta=0$ corresponding to linear dynamics), and $\delta$ is the weighting in based on distance in time ($\delta=0$, the default, corresponding to a regular, stationary model). See the **Nonstationary S-map** section for more details on the nonstationary model. For a Python implementation of this model, go [here](https://github.com/kenflat2/NS-Map). 

## Differences from package `rEDM`

For the same inputs and hyperparameters $E$, $\tau$, and $\theta$, this implementation will produce the same results as S-map in the package [`rEDM`](https://github.com/SugiharaLab/rEDM/). Differences from `rEDM` are:  
1. This implementation will find the maximum likelihood value of $theta$ (and optionally $\delta$) given $E$ and $tau$ using gradient desent (Rprop). If desired, these values can also be fixed. In `rEDM`, one has to conduct a grid search to find the optimal value. 
2. This includes implementation of nonstationary S-map, allowing for weighting in both state space ($\theta$) and time ($\delta$).    
3. The front end is analogous to `fitGP`, and may be more intuitive to use.   
4. This package is written in R and has not been as optimized for speed as `rEDM` (which is C++ based), so it is potentially slower, particularly for large datasets.  

## Differences from `fitGP`

The function `fitSmap` works very similarly to `fitGP`, but there are some differences. GP and S-map also have different hyperparameters, so the inputs and outputs related to those differ. Also, `fitSmap` automatically computes leave-one-out predictions and it is these (instead of the in-sample predictions) that are returned by the function. So, there is no `predictmethod="loo"` because these values are already provided. 

Although you can include/specify multiple populations (`pop`) in `fitSmap`, the S-map model is not hierarchical like the GP model. All populations will be considered replicates with the same dynamics. The advantage of specifying `pop` is that it will prevent crossover when generating lags, it will evaluate population-specific fit statistics, and it will keep the population designations in the results table (useful for plotting). 

## Scaling considerations

Scaling in S-map is not as essential as in the GP model, since $\theta$ is scaled interally to the average distance among points ($d$ in the equation above). If you are doing univariate delay embedding, the results will be unaffected by the scaling of the data. However, if you are fitting a multivariate model, you will need to think about data scaling, since the weights are applied equally in all dimensions, and the predictors are no longer in the same units. It is common to standardize all of the predictors in a multivariate model.

For convenience, this function will scale the input data automatically by default, and backtransform output to the original scale. Scaling options are the same as in `fitGP`. 

## Examples

```{r examples1, fig.height=3}
pA=subset(thetalog2pop, Population=="PopA")

#fit a basic model
m1=fitSmap(pA, y="Abundance", E=1, tau=1, scaling = "none")
summary(m1)

plot(m1)

#results table (predicted and observed)
head(m1$looresults)

#table of s-map coefficients (partial derivatives)
head(m1$loocoefs)

#model with 2 populations
m2=fitSmap(thetalog2pop, y="Abundance", pop="Population", time="Time", E=2, tau=1, scaling="local")
summary(m2)
plot(m2)

#making predictions
p2=predict(m2, predictmethod = "lto")
plot(p2)

#training and testing data
pAlags=makelags(pA, y="Abundance", E=2, tau=1, append=T)
pAtrain=pAlags[1:40,]
pAtest=pAlags[41:50,]
m3=fitSmap(data=pAtrain, y="Abundance", x="Abundance_1", time="Time", newdata=pAtest)
plot(m3)
```

The data can be specified in all the various ways that are possible in `fitGP`.

```{r examples2, eval=FALSE}
Y=pAlags$Abundance
X=pAlags[,"Abundance_1", drop=F]

m1=fitSmap(pAlags, y="Abundance", x="Abundance_1", scaling = "none")
summary(m1)

m1=fitSmap(y=Y, x=X, scaling = "none")
summary(m1)
```

## Nonstationary S-map

The nonstationary S-map can be fit with `fitSmap` by setting `ns=TRUE`. A `time` variable must be specified. The `time` variable will be used by default for the temporal weighting. If you want to associate a different variable with $\delta$ that isn't time, one can be specified under `nsvar`. 

Note that the `time` variable (or other `nsvar`) will *not* be scaled, no matter what the `scaling` setting is. The value of $\delta$ will depend on the time units, so you should rescale time (or not) prior to model fitting depending on what you'd like $\delta$ to reflect.

```{r nsmap1}
#some stationary and nonstationary series
data("NSseries")

ggplot(NSseries, aes(x=timestep, y=val)) +
  facet_wrap(model*ns~., scales = "free_y", nrow = 2, dir = "v") +
  geom_point() + geom_line()

#if the rate of nonstationarity change is small, delta sometimes converges
#faster and more precisely if you rescale time to 0-1.
nsteps=max(NSseries$timestep)
NSseries$timestep2=NSseries$timestep/nsteps

#nonstationary model with fixed E
series1=subset(NSseries, seriesnum==1)
m1=fitSmap(data=series1, y="val", E=3, tau=1, scaling = "none",
           ns=TRUE, time = "timestep2")
summary(m1)

#to get delta in the original time units, divide by nsteps^2
m1$delta/nsteps^2
```

Over-embedding can potentially conceal nonstationarity because nonstationarity is compensated for by the additional lags. Thus a better test of nonstationarity evaluates it over a range of `E` values and takes a weighted average of $\delta$ based on likelihood ($\delta_{agg}$). This can be done with `Smap_NStest`.

```{r nsmap2}
res=Smap_NStest(data=series1, y="val", time="timestep2", Emax=6)

#there is a plotting method for the output, which plots the time series, logL, 
#delta value, weights, degrees of freedom, and leave-one-out R2 as functions of E.
plot(res)

#the delta_agg value doesn't depend on the stationary model values (delta fixed to 0), 
#so to save time, you can turn off the fitting of the stationary models. 
res=Smap_NStest(data=series1, y="val", time="timestep2", Emax=6, fitStationary = FALSE)

#the method is able to distinguish stationary, nonstationary, linear, and nonlinear dynamics
results=unique.data.frame(NSseries[,1:3])
results$delta_agg=NA
Emax=6

r1list=list()
for(i in seq_along(results$seriesnum)) {
  test=subset(NSseries, seriesnum==results$seriesnum[i])
  res=Smap_NStest(data=test, y="val", time="timestep2", Emax=Emax, fitStationary = FALSE)
  r1list[[i]]=res$results
  results$delta_agg[i]=res$delta_agg
}
#get the value of theta at the highest R2
results$thetamaxR2=sapply(r1list, FUN = function(results) {
  c(results$theta, results$theta_NS)[which.max(c(results$R2, results$R2_NS))]})

results
```

Here's an example of a time series that is statistically nonstationary but dynamically stationary. Nonstationary S-map classifies it as stationary.

```{r nsmap3}
set.seed(1)

#time
ti=1:100
#a noisy sinusoid
yi=sin(2*pi/12*ti)+rnorm(100,0,0.05)
#an AR1 with a transient
yii=numeric(100); yii[1]=10
a=0.95
for(i in 2:100) {
  yii[i]=yii[i-1]*a+rnorm(1,0,0.5)
}
#AR1 plus the sinusoid
yiii=yi+yii
yvi=yi+0.3*yii

par(mfrow=c(2,2), mar=c(4,4,2,1))
plot(ti,yi,type="l",main="sinusoid")
plot(ti,yii,type="l",main="AR1")
plot(ti,yiii,type="l",main="sinusoid+AR1")
plot(ti,yvi,type="l",main="sinusoid+0.3*AR1")
```

```{r nsmap4, eval=FALSE}
df=data.frame(ti=ti, yi=yi, yii=yii, yiii=yiii, yvi=yvi)

res=Smap_NStest(data=df, y="yi", time="ti", Emax=4, summaryonly=T, scaling = "none")
res$results
plot(res)

res=Smap_NStest(data=df, y="yii", time="ti", Emax=8, summaryonly=T, scaling = "none")
res$results
plot(res)

res=Smap_NStest(data=df, y="yiii", time="ti", Emax=4, summaryonly=T, scaling = "none")
res$results
plot(res)

res=Smap_NStest(data=df, y="yvi", time="ti", Emax=8, summaryonly=T, scaling = "none")
res$results
plot(res)
```

## References

Sugihara G. 1994. Nonlinear forecasting for the classification of natural time series. Philosophical Transactions: Physical Sciences and Engineering, 348 (1688) : 477â€“495.

Gee K, Rogers TL, Munch SB. In prep. Quantifying nonstationarity in ecological time series.
